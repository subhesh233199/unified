<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RRR Analysis Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked@4.0.12/lib/marked.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.9.2/html2pdf.bundle.min.js"></script>
</head>
<body>

    
        <h1 class="text-3xl font-bold mb-6 text-center">RRR Analysis Tool</h1>


        
            
                
                    <form id="folderForm">
                        <label class="block text-lg font-medium text-gray-700">Enter Folder Path</label>
                        <input type="text" id="folderPath" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2">
                    
                
                    
                        <label class="inline-flex items-center">
                            <input type="checkbox" id="clearCache" class="form-checkbox h-5 w-5 text-blue-600">
                            <span class="ml-2 text-gray-700">Clear Cache</span>
                        </label>
                    
                
                    
                        <button type="submit" class="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600">
                            Analyze
                        </button>
                    
                </form>
            


        
            <div id="loading" class="hidden text-center">

            <p>Analyzing PDFs... This may take a few minutes.</p>
            </div>


        
            <div id="reportSection" class="hidden">
                <h2 class="text-2xl font-semibold mb-4">Analysis Report</h2>

            
                <button id="editReport" class="bg-green-500 text-white px-4 py-2 rounded-md hover:bg-green-600">Edit Report</button>
                <button id="saveChanges" class="hidden bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600">Save Changes</button>
                <button id="cancelEdit" class="hidden bg-gray-500 text-white px-4 py-2 rounded-md hover:bg-gray-600">Cancel</button>
                <button id="downloadHtml" class="bg-purple-500 text-white px-4 py-2 rounded-md hover:bg-purple-600">Download HTML</button>
                <button id="downloadPdf" class="bg-red-500 text-white px-4 py-2 rounded-md hover:bg-red-600">Download PDF</button>
            

            <div id="reportContent"></div>
            <textarea id="reportEditor" class="hidden w-full h-96 border border-gray-300 rounded-md p-4"></textarea>
            </div>


        
            <div id="visualizationsSection" class="hidden">
                <h2 class="text-2xl font-semibold mb-4">Visualizations</h2>

            <div id="visualizationsContent"></div>
            </div>


        
            <div id="evaluationSection" class="hidden">
                <h2 class="text-2xl font-semibold mb-4">Evaluation</h2>

            <div id="evaluationContent"></div>
            </div>


        
            <div id="hyperlinksSection" class="hidden">
                <h2 class="text-2xl font-semibold mb-4">Hyperlinks</h2>

            <div id="hyperlinksContent"></div>
            </div>

        

    
    <script>
        let originalReport = '';
        let currentMetrics = {};

        document.getElementById('folderForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            await analyzePDFs();
        });

        async function analyzePDFs() {
            const folderPath = document.getElementById('folderPath').value;
            const clearCache = document.getElementById('clearCache').checked;
            if (!folderPath) {
                alert('Please enter a folder path');
                return;
            }

            showLoading(true);
            try {
                const response = await fetch('http://127.0.0.1:8080/analyze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ folder_path: folderPath, clear_cache: clearCache })
                });
                if (!response.ok) throw new Error(`Analysis failed: ${response.statusText}`);
                const data = await response.json();
                currentMetrics = JSON.parse(JSON.stringify(data.metrics));
                originalReport = data.report;
                displayResults(data);
            } catch (error) {
                console.error('Error:', error);
                alert('Failed to analyze PDFs. Please check the server and folder path.');
            } finally {
                showLoading(false);
            }
        }

        function showLoading(show) {
            document.getElementById('loading').classList.toggle('hidden', !show);
            document.getElementById('reportSection').classList.add('hidden');
            document.getElementById('visualizationsSection').classList.add('hidden');
            document.getElementById('evaluationSection').classList.add('hidden');
            document.getElementById('hyperlinksSection').classList.add('hidden');
        }

        function displayResults(data) {
            // Report
            document.getElementById('reportContent').innerHTML = marked.parse(data.report);
            makeTablesEditable();
            document.getElementById('reportSection').classList.remove('hidden');

            // Visualizations
            const vizContent = document.getElementById('visualizationsContent');
            vizContent.innerHTML = '';
            data.visualizations.forEach((base64, index) => {
                const img = document.createElement('img');
                img.src = `data:image/png;base64,${base64}`;
                img.alt = `Visualization ${index + 1}`;
                img.className = 'w-full h-auto';
                vizContent.appendChild(img);
            });
            document.getElementById('visualizationsSection').classList.remove('hidden');

            // Evaluation
            document.getElementById('evaluationContent').innerHTML = `
                <p><strong>Score:</strong> ${data.evaluation.score}</p>
                <p><strong>Evaluation:</strong> ${data.evaluation.text}</p>
            `;
            document.getElementById('evaluationSection').classList.remove('hidden');

            // Hyperlinks
            const hyperlinksContent = document.getElementById('hyperlinksContent');
            hyperlinksContent.innerHTML = '';
            data.hyperlinks.forEach(link => {
                const div = document.createElement('div');
                div.innerHTML = `
                    <p><strong>URL:</strong> <a href="${link.url}" target="_blank" class="text-blue-500 hover:underline">${link.url}</a></p>
                    <p><strong>Context:</strong> ${link.context}</p>
                    <p><strong>Page:</strong> ${link.page}</p>
                    <p><strong>Source:</strong> ${link.source_file}</p>
                    <hr class="my-2">
                `;
                hyperlinksContent.appendChild(div);
            });
            document.getElementById('hyperlinksSection').classList.remove('hidden');
        }

        function makeTablesEditable() {
            const tables = document.querySelectorAll('#reportContent table');
            tables.forEach(table => {
                const headers = Array.from(table.querySelectorAll('th')).map(th => th.textContent.trim());
                const rows = table.querySelectorAll('tr');
                rows.forEach((row, rowIndex) => {
                    if (rowIndex === 0) return; // Skip header
                    const cells = row.querySelectorAll('td');
                    cells.forEach((cell, cellIndex) => {
                        const header = headers[cellIndex];
                        if (['Value', 'Pass Count', 'Fail Count'].includes(header)) {
                            cell.setAttribute('contenteditable', 'true');
                            cell.addEventListener('input', () => updateMetricsFromTable(table, rowIndex, cellIndex, cell.textContent));
                        }
                    });
                });
            });
        }

        function updateMetricsFromTable(table, rowIndex, cellIndex, newValue) {
            const headers = Array.from(table.querySelectorAll('th')).map(th => th.textContent.trim());
            const header = headers[cellIndex];
            const sectionHeader = table.previousElementSibling?.textContent.trim();
            const version = table.rows[rowIndex].cells[0].textContent.trim();
            newValue = parseFloat(newValue.replace(/[^0-9.]/g, '')) || 0;

            let metricName, subMetric, client;
            if (sectionHeader?.includes('Customer Specific Testing')) {
                client = sectionHeader.match(/(RBS|Tesco|Belk)/)?.[1];
                metricName = 'Customer Specific Testing (UAT)';
            } else {
                metricName = sectionHeader?.replace('(ATLS)', '').replace('(BTLS)', '').trim();
                subMetric = sectionHeader?.includes('ATLS') ? 'ATLS' : sectionHeader?.includes('BTLS') ? 'BTLS' : null;
            }

            if (client && metricName in currentMetrics.metrics) {
                const uatMetrics = currentMetrics.metrics[metricName][client];
                const item = uatMetrics.find(item => item.version === version);
                if (item) {
                    if (header === 'Pass Count') item.pass_count = newValue;
                    if (header === 'Fail Count') item.fail_count = newValue;
                }
            } else if (subMetric && metricName in currentMetrics.metrics) {
                const items = currentMetrics.metrics[metricName][subMetric];
                const item = items.find(item => item.version === version);
                if (item && header === 'Value') item.value = newValue;
            } else if (metricName in currentMetrics.metrics && Array.isArray(currentMetrics.metrics[metricName])) {
                const items = currentMetrics.metrics[metricName];
                const item = items.find(item => item.version === version);
                if (item && header === 'Value') item.value = newValue;
            }
        }

        document.getElementById('editReport').addEventListener('click', () => {
            document.getElementById('reportContent').classList.add('hidden');
            document.getElementById('reportEditor').value = originalReport;
            document.getElementById('reportEditor').classList.remove('hidden');
            document.getElementById('editReport').classList.add('hidden');
            document.getElementById('saveChanges').classList.remove('hidden');
            document.getElementById('cancelEdit').classList.remove('hidden');
        });

        document.getElementById('saveChanges').addEventListener('click', async () => {
            const folderPath = document.getElementById('folderPath').value;
            if (!folderPath) {
                alert('Folder path is required to save changes');
                return;
            }
            const editedReport = document.getElementById('reportEditor').value;

            showLoading(true);
            try {
                const response = await fetch('http://127.0.0.1:8080/update_metrics', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder_path: folderPath,
                        metrics: currentMetrics,
                        report: editedReport
                    })
                });
                if (!response.ok) throw new Error(`Failed to save changes: ${response.statusText}`);
                const data = await response.json();
                currentMetrics = JSON.parse(JSON.stringify(data.metrics));
                originalReport = data.report;
                displayResults(data);
                cancelEdit();
            } catch (error) {
                console.error('Error:', error);
                alert('Failed to save changes. Please check the server.');
            } finally {
                showLoading(false);
            }
        });

        document.getElementById('cancelEdit').addEventListener('click', cancelEdit);
        function cancelEdit() {
            document.getElementById('reportContent').innerHTML = marked.parse(originalReport);
            makeTablesEditable();
            document.getElementById('reportContent').classList.remove('hidden');
            document.getElementById('reportEditor').classList.add('hidden');
            document.getElementById('editReport').classList.remove('hidden');
            document.getElementById('saveChanges').classList.add('hidden');
            document.getElementById('cancelEdit').classList.add('hidden');
        }

        document.getElementById('downloadHtml').addEventListener('click', () => {
            const blob = new Blob([document.getElementById('reportContent').innerHTML], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'report.html';
            a.click();
            URL.revokeObjectURL(url);
        });

        document.getElementById('downloadPdf').addEventListener('click', () => {
            const element = document.getElementById('reportContent');
            html2pdf().from(element).save('report.pdf');
        });
    </script>
</body>
</html>
